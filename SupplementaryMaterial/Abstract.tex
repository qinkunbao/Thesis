% Place abstract below.

\vspace{-0.3in}
Side-channel attacks can leak secret information unconsciously from non-functional characteristics, e.g., time, power, and memory usage. Similar to many other vulnerabilities in software, attackers exploit the flaws in designs of hardware and implementations of software. Contrary to the the hardware countermeasures, which usually need changes to the complex underlying hardware, software solutions are more easier to adopt in many scenarios. This dissertation study various aspects of the side-channel vulnerabilities.

The dissertation first introduces a new method to detect address-based side-channel in the binary code. While existing approaches can identify side-channel leakages in real-world programs. We notice that while some existing work can detect side-channel leakages. Many of them are computationally expensive and apply some domain knowledge to simplify the analysis.  We examine the bottleneck of current symbolic approaches and scaling it production-system crypto analysis. The evaluation results confirm that the approach is much faster than the state of art tools while identifying all the known leakages reported by previous tools.

Second, while current side-channel detection work is able to identify numerous potential vulnerabilities. However, in practice, many such vulnerabilities leak a negligible amount of sensitive information, and thus developers are often reluctant to address them. Existing tools do not provide information to evaluate a leak’s severity, such as the number of leaked bits. To address this issue, we propose a new program analysis method to precisely quantify the leaked information in a single-trace attack through side-channels. It can identify covert information flows in programs that expose confidential information and can reason about security flaws that would otherwise be difficult, if not impossible, for a developer to find. We model an attacker’s observation of each leakage site as a constraint. We use symbolic execution to generate these constraints and then run Monte Carlo sampling to estimate the number of leaked bits for each leakage site. By applying the Central Limit Theorem, we provide an error bound for these estimations. The evaluation results shows that our method can successfully distinguish severe leakages from many negligible leakages.

Third, we extend our approach to quantify side-channel leakages from multiple trace attacks. In this work, we present MME, an address-based side-channel detection and quantification tool that can quantify the side-channel leakages in a conservation but precise way. Contrary to previous side-channel detection tools, our approach can identify those really severe side-channel leakages without false positives. Moreover, our tools can estimate the total effect of multiple leakage sites as well. MME consists of three steps. First, the target program is running with a number of the sensitive inputs to record the memory access under different inputs. Second, the long address traces are split into several segments based on the location in the source code. Finally, we analyze the memory-access information from those segments and compare the address access information with the original source code. Based on the channel capacity between the original secrets and the observation of the attacker, we quantify the information leakages for each leakage site. We evaluate MME with OpenSSL, mbedTLS, TinyDNN and GTK. Our evaluation results show MME is effective in identifying and quantifying side-channel leakages.
