% !TEX root = ../YourName-Dissertation.tex

\chapter{Introduction} \label{chapter1}

Side channels are inevitable in modern computer systems as the sensitive
information may be leaked through many kinds of inadvertent behaviors, such as power, electromagnetic radiation, and even
sound~\cite{agrawal2002side,kar20178,chari1999towards,217605,genkin2014rsa}.
Among them, address-based side channel attacks, such as cache attacks, memory page attacks, and controlled-channel attacks, are especially common and have been studied for years~\cite{7163052,217543,217589,lee2017inferring,191010,liu2015last}. These
attacks result from vulnerable software and shared hardware components.
By observing program outputs or hardware behaviors, attackers can infer program
execution flows that manipulate secrets and guess secrets such as encryption
keys~\cite{Osvik2006,Gullasch:2011:CGB:2006077.2006784,203878,10.1007/978-3-540-45238-6_6}.

In this chapter, we first introduce two code patterns that can be exploited to retrieve sensitive information. After that, we discuss some common attacks and corresponding defense strategies. The limitations of existing work motivate the research in the dissertation. Finally, we summarize the contributions of the dissertation.

\section{Address-based Side-channel}
\subsection{Attack}
Address-based side-channel attacks happen when a program has different behaviors when it accesses different memory addresses. Most of the attack allows the attacker to shares some hardware resources (e.g., CPU Cache, TLB, and DRAM) with the victim. As a result, while the root reason of the attack is the same, there are various approaches that can exploit the attack at different granularities. 

Cache channels rely on the time difference between cache misses and cache hits. A cache channel works when the victim program and the attacker's program shares some sized chunks like cache lines or cache sets. Recent studies shows that an attacker can even observe the address access at a finer granularity (e.g., CacheBleed). Page-level side-channels allow attackers observe the memory access at the granularity of memory pages. 

In this dissertation, we consider three types of granularity: byte (1 Byte), cache line size (64 Bytes), page size (4 KBs). To the best of our knowledge, the three types of granularities can cover most of the side-channel attacks in literature.

When we examine those side-channel attacks, many of them stem from the two code patterns, \emph{secret-dependent control-flow transfers} and \emph{secret-dependent data accesses}.
\begin{figure}[h]
\begin{lstlisting}[xleftmargin=.32\textwidth, xrightmargin=.32\textwidth]
int secret[32];
...
while(i>0){
    r = (r * r) % n;
    if(secret[--i] == 1)
        r = (r * x) % n;   
}
\end{lstlisting}
\caption{Secret-dependent control-flow transfers}
\label{fig:secret:cf}
\end{figure}

Secret-dependent control-flow transfers happen when the value of secret can affect which branch the code executes. Figure~\ref{fig:secret:cf} shows an example. Depending on the value of \textsf{secret}, the code may or may not execute the code at line 6. As attackers, they can retrieve some information based on the execution control-flow. 

\begin{figure}[h]
\begin{lstlisting}[xleftmargin=.32\textwidth, xrightmargin=.32\textwidth]
static char FSb[256] = {...}
... 
uint32_t a = *RK++ ^ \ 
(FSb[(secret)) ^
(FSb[(secret >> 8)] << 8 ) ^
(FSb[(secret >>16)] << 16 ) ^
(FSb[(secret >>24)] << 24 );
...
\end{lstlisting}
\caption{Secret-dependent data accesses}
\label{fig:secret:da}
\end{figure}

Secret-dependent data accesses happen when the value of the secret can affect which memory cell the code reads or writes. Figure~\ref{fig:secret:da} shows an example. \textsf{FSb} is an array. Depending on the value of \textsf{secret}, the code may read or write different items in the array. 

\subsection{Defense}



Both hardware~\cite{Page2005PartitionedCA,
Wang:2007:NCD:1250662.1250723,Zhang:2015:HDL:2775054.2694372,Li:2014:SLH:2541940.2541947,
236344, 236334} and software~\cite{shih2017t,Coppens:2009:PMT:1607723.1608124,
brickell2006software,crane2015thwarting, 197207} side-channels mitigation techniques have
been proposed recently. Hardware countermeasures, including partitioning hardware resources~\cite{Page2005PartitionedCA}, randomizing cache
accesses~\cite{Wang:2007:NCD:1250662.1250723, 236344}, and designing new
architecture~\cite{tiwari2011crafting}, require changes to complex processors and are complex to adopt. 

On the contrary, software approaches are
usually easy to implement. The basic idea is to eliminate key-dependent
control-flow transfers and data accesses. By removing the above two kinds of code patterns, developers protect their 
code from a series of side-channel attacks.


However, it is still hard to apply software approaches in practice due to the following reasons.

\begin{enumerate}
    \item It is hard to identify side-channel vulnerabilities in real-world software. In general, many side-channel vulnerabilities are low-level problems. Control-flows or memory accesses may not be side-channel vulnerabilities if they are independent of original secret inputs. Recent work can identify side-channel leakages. But those tools can only work on small programs or need to apply some domain knowledge to simplify the analysis. 
    \item Side-channel vulnerabilities are ubiquitous. While some vulnerabilities can result in the key being entirely compromised, many other vulnerabilities are hard to exploit. Moreover, some vulnerable implementations perform better. Recent work can identify thousands of leaked points, but most of them are not patched by developers because those leakages are either false positives or leaked very little information.  
\end{enumerate}


\section{Contribution}
To address Problem 1, we make the following contributions on detecting side-channel leakages:

\begin{itemize}
    \item We designs a symbolic analysis method that can detect secret-dependent control-flow transfers and secret-dependent data access. The key idea is to only symbolically execute those machine instructions that are relevant to vulnerabilities while executing other instructions natively.
    \item We implement the above method in a tool called ~\detect{}. The evaluation results shows that ~\detect{}  is 3 to 100 times faster than existing tools while identifying all vulnerabilities when we run it on the same library.  We do not need to apply domain knowledge to only part of the original program, which simplify the analysis. In addition, ~\detect{} yields new leakages which are not identified by previous tools. We confirm those findings with developers.
\end{itemize}

To address Problem 2, we make the following contributions on quantifying side-channel leakages in a single trace attack:


\begin{itemize}
    \item We propose a method that can quantify fine-grained leaked
    information from side-channel vulnerabilities that result from actual attack
    scenarios in a single trace attack. Our approach differs from previous ones in that we
    model real attack scenarios for one execution. 
    We model the information quantification problem as a counting problem 
    and use a Monte Carlo sampling method to estimate the information leakage.
    \item We implement the method into a tool and apply it
    to several pieces of real software. \tool{} successfully identifies
    previous unknown and known side-channel vulnerabilities and calculates the corresponding information leakage. 
    Our results are useful in practice.
    The leakage estimates and the corresponding trigger inputs can 
    help developers to triage and fix the vulnerabilities.
\end{itemize}

To address Problem 2, we make the following contributions on quantifying side-channel leakages on chosen plaintext side-channel attacks: 
\begin{itemize}
    \item We propose a novel method that can detect and analyze the effect of each side-channel leakage sites automatically. Our analysis combine information from both the source code and the run-time execution, which makes the method more effective in finding the leakages. The method can combine multiple leakage sites to retrieve more information as well.
    \item We analyze the amount of information leakage from side-channel vulnerabilities based on the channel capacity. We propose a method that can estimate the lower bound of information leakages. The theory can serve as the foundation of the future work on quantify the information leakage based on the fuzzing.
    \item We implement the above method in a tool called \ctool{} and evaluate the tool with several benchmarks and several real-world applications such as OpenSSL, mbedTLS, TinyDNN, and GTK. The results show that our tool can detect and quantify the side-channel leakages effectively. Moreover, the leakage reports given by the \ctool{} can help developers fix the reported vulnerabilities.
\end{itemize}


\section{Dissertation Organization}
The rest of the dissertation is organized as follows. We first present relevant backgrounds and related works in Chapter~\ref{chapter1}. We then propose our works in
Chapter~\ref{chapter2}. Chapter~\ref{chapter3} and Chapter~\ref{chapter4} introduce
our recent progress about the proposed work. 
