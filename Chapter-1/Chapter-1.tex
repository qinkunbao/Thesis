% !TEX root = ../YourName-Dissertation.tex

\chapter{Introduction} \label{chapter1}
Side channels are ubiquitous in modern computer systems as sensitive
information can leak through many mechanisms such as power,
electromagnetic radiation, and even sound~\cite{agrawal2002side,kar20178,chari1999towards,217605,genkin2014rsa}.
It is typically hard to fix all side-channel vulnerabilities for real-world software systems. Among them, software side-channel attacks, such as cache attacks, memory page attacks, and controlled-channel attacks, are especially problematic as they do not require physical proximity~\cite{7163052,217543,217589,lee2017inferring,191010,liu2015last}. These attacks arises from shared micro-architectural components in a computer processor. By observing inadvertent interactions between two programs, attackers can infer program execution flows that manipulate secrets and guess secrets such as encryption keys~\cite{Osvik2006,Gullasch:2011:CGB:2006077.2006784,203878,10.1007/978-3-540-45238-6_6}.

Various countermeasures have been proposed to defend against
side channel attacks. Hardware-level solutions, such as reducing shared
resources, adopting oblivious RAM, and using transnational
memory~\cite{203878,217537,shih2017t,Zhang:2015:HDL:2775054.2694372}, need new
hardware features and changes in modern complex computer systems, which are
hard to adopt in reality. Therefore, a promising and universal direction is software countermeasures, detecting and eliminating side channel vulnerabilities from code base. It is due to the following reason: many side-channel attacks originate in two code patterns: data flow from secrets to load addresses and data flow from secrets to branch conditions. We refer to them as secret-dependent data accesses and control flows respectively in the dissertation. 

However, eliminating side channel vulnerabilities from real-world software code base is not easy. First, some vulnerable implementations perform better. For example, RSA implementations usually adopt the CRT optimization,
which is faster but vulnerable to fault attacks~\cite{aumuller2002fault}. Fixing vulnerabilities can introduce new 
weaknesses. Second, it is hard to detect side channels in reality. While recent work~\cite{203878,217537,Wichelmann:2018:MFF:3274694.3274741,Brotzman19Casym,236338,182946} can detect many side-channel vulnerabilities, they either suffer from expensive computation cost or high false positives and false negatives. Recent work~\cite{203878,217537,Wichelmann:2018:MFF:3274694.3274741,Brotzman19Casym,236338,182946} can detect many side-channel vulnerabilities. For example, DATA~\cite{217537} reports 2,248 potential leakage sites for the RSA implementation in OpenSSL 1.1.0f\@. Further analysis shows 1,510 leaks can be dismissed. But that leaves 460 data-access leaks and 278 control-flow leaks. Many of these vulnerabilities have not been fixed by developers for a variety of reasons. Third, most vulnerabilities pose a negligible risk. 
Although some vulnerabilities result in the key being 
entirely compromised~\cite{184415, aumuller2002fault}, 
many others are less severe in reality. Therefore, we need a proper quantification metric to assess the sensitivity of side-channel vulnerabilities, so a developer can efficiently triage them.

Previous work~\cite{182946,5207642} can identify numerous leakages or even provide an upper bound on the amount of leakage, which is useful to verify that an implementation is secure if it incurs zero leakage.
However, these techniques cannot quantify the severity of a leak because they over approximate the leakage. For example, CacheAudit~\cite{182946} 
reports that the upper-bound leakage of AES-128 exceeds the original key size. Besides, existing side-channel quantification work~\cite{182946,5207642} assumes an attacker runs the target program multiple times with different
input secrets and calculates an ``average'' estimation, which is different from real attack scenarios when the secret that an attacker wants to retrieve is fixed. As a consequence, those results are less useful to assess the severity level of each leakage site.

We try to address the above problem from the following aspects.
\begin{enumerate}
\item In terms of side-channel vulnerability detections, we propose a fast and precise side-channel detection method. 
\item We propose a novel method to quantify information 
leakage precisely from a single trace attack. We quantify the number of bits that can leak during a real execution and define the amount of leaked information as the cardinality of possible secrets based on an attacker's observation. Before an attack, an adversary has a large but finite input space. Whenever the adversary observes a leakage site, they can eliminate some impossible inputs and reduce the input space's size. In an extreme case, if the input space's size reduces to one, an adversary has determined the input, which means all secret information (e.g., the entire secret key) is
leaked. By counting the number of inputs~\cite{10.1007/11499107_24}, we can quantify the information leakage precisely. We use symbolic execution to generate constraints to model the relation 
between the original sensitive input and an attacker's observations. 
Symbolic execution provides fine-grained information, but it is expensive
to compute. Therefore, prior symbolic
execution work~\cite{203878,236338,Brotzman19Casym} either analyzes only
small programs or applies domain knowledge~\cite{203878} to simplify the analysis. We examine the bottleneck of the trace-oriented symbolic execution and optimize it to work for real-world crypto-systems.

\end{enumerate}





\section{Address-based Side-channel}
\subsection{Attack}
Address-based side-channel attacks happen when a program has different behaviors when it accesses different memory addresses. Most systems allows the attacker to shares some hardware resources (e.g., CPU Cache, TLB, and DRAM) with the victim. As a result, while the root reason of the attack is the same, there are various approaches that can exploit the attack at different granularities. 

Cache channels rely on the time difference between cache misses and cache hits. A cache channel works when the victim program and the attacker's program shares some sized chunks like cache lines or cache sets. Recent studies shows that an attacker can even observe the address access at a finer granularity (e.g., CacheBleed). Page-level side-channels allow attackers observe the memory access at the granularity of memory pages. 

In this dissertation, we consider three types of granularity: byte (1 Byte), cache line size (64 Bytes), page size (4 KBs). To the best of our knowledge, the three types of granularities can cover most of the side-channel attacks in literature.

When we examine those side-channel attacks, many of them stem from the two code patterns, \emph{secret-dependent control-flow transfers} and \emph{secret-dependent data accesses}.
\begin{figure}[h]
\begin{lstlisting}[xleftmargin=.32\textwidth, xrightmargin=.32\textwidth]
int secret[32];
...
while(i>0){
    r = (r * r) % n;
    if(secret[--i] == 1)
        r = (r * x) % n;   
}
\end{lstlisting}
\caption{Secret-dependent control-flow transfers}
\label{fig:secret:cf}
\end{figure}

Secret-dependent control-flow transfers happen when the value of secret can affect which branch the code executes. Figure~\ref{fig:secret:cf} shows an example. Depending on the value of \textsf{secret}, the code may or may not execute the code at line 6. As attackers, they can retrieve some information based on the execution control-flow. 

\begin{figure}[h]
\begin{lstlisting}[xleftmargin=.32\textwidth, xrightmargin=.32\textwidth]
static char FSb[256] = {...}
... 
uint32_t a = *RK++ ^ \ 
(FSb[(secret)) ^
(FSb[(secret >> 8)] << 8 ) ^
(FSb[(secret >>16)] << 16 ) ^
(FSb[(secret >>24)] << 24 );
...
\end{lstlisting}
\caption{Secret-dependent data accesses}
\label{fig:secret:da}
\end{figure}

Secret-dependent data accesses happen when the value of the secret can affect which memory cell the code reads or writes. Figure~\ref{fig:secret:da} shows an example. \textsf{FSb} is an array. Depending on the value of \textsf{secret}, the code may read or write different items in the array. 

\subsection{Defense}



Both hardware~\cite{Page2005PartitionedCA,
Wang:2007:NCD:1250662.1250723,Zhang:2015:HDL:2775054.2694372,Li:2014:SLH:2541940.2541947,
236344, 236334} and software~\cite{shih2017t,Coppens:2009:PMT:1607723.1608124,
brickell2006software,crane2015thwarting, 197207} side-channels mitigation techniques have
been proposed recently. Hardware countermeasures, including partitioning hardware resources~\cite{Page2005PartitionedCA}, randomizing cache
accesses~\cite{Wang:2007:NCD:1250662.1250723, 236344}, and designing new
architecture~\cite{tiwari2011crafting}, require changes to complex processors and are complex to adopt. 

On the contrary, software approaches are
usually easy to implement. The basic idea is to eliminate key-dependent
control-flow transfers and data accesses. By removing the above two kinds of code patterns, developers protect their 
code from a series of side-channel attacks.


However, it is still hard to apply software approaches in practice due to the following reasons.

\begin{enumerate}
    \item It is hard to identify side-channel vulnerabilities in real-world software. In general, many side-channel vulnerabilities are low-level problems. Control-flows or memory accesses may not be side-channel vulnerabilities if they are independent of original secret inputs. Recent work can identify side-channel leakages. But those tools can only work on small programs or need to apply some domain knowledge to simplify the analysis. 
    \item Side-channel vulnerabilities are ubiquitous. While some vulnerabilities can result in the key being entirely compromised, many other vulnerabilities are hard to exploit. Moreover, some vulnerable implementations perform better. Recent work can identify thousands of leaked points, but most of them are not patched by developers because those leakages are either false positives or leaked very little information.  
\end{enumerate}


\section{Contribution}
We address above problems from two aspects. First, we propose a novel method that can detect side-channel vulnerabilities in real-world applications automatically fast and precisely. Second, we propose methods that can quantify each side-channel leakages precisely. In addition, we study two kinds of threat models, single-trace attacks, and chosen message attacks.

In summary, we make the following contributions:

To address Problem 1, we make the following contributions on detecting side-channel leakages:

\begin{itemize}
    \item We designs a symbolic analysis method that can detect secret-dependent control-flow transfers and secret-dependent data access. The key idea is to only symbolically execute those machine instructions that are relevant to vulnerabilities while executing other instructions natively.
    \item We implement the above method in a tool called ~\detect{}. The evaluation results shows that ~\detect{}  is 3 to 100 times faster than existing tools while identifying all vulnerabilities when we run it on the same library.  We do not need to apply domain knowledge to only part of the original program, which simplify the analysis. In addition, ~\detect{} yields new leakages which are not identified by previous tools. We confirm those findings with developers.
\end{itemize}

To address Problem 2, we make the following contributions on quantifying side-channel leakages in a single trace attack:


\begin{itemize}
    \item We propose a method that can quantify fine-grained leaked
    information from side-channel vulnerabilities that result from actual attack
    scenarios in a single trace attack. Our approach differs from previous ones in that we
    model real attack scenarios for one execution. 
    We model the information quantification problem as a counting problem 
    and use a Monte Carlo sampling method to estimate the information leakage.
    \item We implement the method into a tool and apply it
    to several pieces of real software. \tool{} successfully identifies
    previous unknown and known side-channel vulnerabilities and calculates the corresponding information leakage. 
    Our results are useful in practice.
    The leakage estimates and the corresponding trigger inputs can 
    help developers to triage and fix the vulnerabilities.
\end{itemize}

To address Problem 2, we make the following contributions on quantifying side-channel leakages on chosen plaintext side-channel attacks: 
\begin{itemize}
    \item We propose a novel method that can detect and analyze the effect of each side-channel leakage sites automatically. Our analysis combine information from both the source code and the run-time execution, which makes the method more effective in finding the leakages. The method can combine multiple leakage sites to retrieve more information as well.
    \item We analyze the amount of information leakage from side-channel vulnerabilities based on the channel capacity. We propose a method that can estimate the lower bound of information leakages. The theory can serve as the foundation of the future work on quantify the information leakage based on the fuzzing.
    \item We implement the above method in a tool called \ctool{} and evaluate the tool with several benchmarks and several real-world applications such as OpenSSL, mbedTLS, TinyDNN, and GTK. The results show that our tool can detect and quantify the side-channel leakages effectively. Moreover, the leakage reports given by the \ctool{} can help developers fix the reported vulnerabilities.
\end{itemize}


\section{Dissertation Organization}
The rest of the dissertation is organized as follows. We present relevant backgrounds and related works in Chapter~\ref{chapter2}. Chapter~\ref{chapter3} presents a novel method to detect side-channel vulnerabilities in binary executables. Chapter~\ref{chapter4} presents a method that can quantify each side-channel leakage in a single trace attack. Chapter~\ref{chapter5} extends the approach and quantifies the side-channel leakage in chosen message attacks. Chapter~\ref{chapter6} concludes the thesis.