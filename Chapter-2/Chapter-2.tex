% !TEX root = ../YourName-Dissertation.tex

\chapter{Related Work}\label{chapter2}
This dissertation studies address-based side-channel attacks. We review the related work in this chapter. The related work covers the following aspects: side-channel attacks, detections, mitigation, information quantification, and current binary analysis tools.

\section{Side-channel Attacks}
While there are many kinds of side-channel attacks, we focus on address-based side-channel attacks in this dissertation.
Address-based side-channel attacks happen when a program accesses different memory locations when it processes different secrets. In modern computer ssytems, an attacker may shares some hardware resources (e.g., Cache, TLB, and DRAM) with the victim~\cite{ge2018survey,szefer2019survey}. An attacker can probe the shared hardware resource to infer the memory accesses of the victim. While the root cause of the attack is the same, there are many approaches, and an attacker can exploit the vulnerability in different methods to retrieve the information at different granularities.

\begin{table}
    \centering
    \caption{Due to the page limit, we only shows some representations of the vast side-channel attacks: Attacks, the shared resources with attackers, the granularity of the attacker can observe, is there any published attacks on non-cryptography library and if the type of attack have been used to exploit multiple leakage sites.}
    \label{table:side_channel_attack}
    \resizebox{\columnwidth}{!}{%

        \begin{tabular}{lllcc}
            \toprule
            Attacks                                           & Shared Resources & Granularity            & Non-Crpyto & Multiple \\ \midrule
            CacheBleed~\cite{yarom2017cachebleed}             & Cache            & Sub Cache Line (<64 B) & \xmark     & \xmark   \\
            CopyCat~\cite{moghimi2020copycat}                 & Page Tables      & Instruction            & \xmark     & \xmark   \\
            Prime + Probe~\cite{liu2015last}                  & Cache            & Cache Set (64-512 B)   & \cmark     & \xmark   \\
            Prime + Abort~\cite{disselkoen2017prime+}         & Cache            & Cache Set (64-512 B)   & \cmark     & \xmark   \\
            Flush + Reload~\cite{yarom2014flush+}             & Cache            & Cache Line (64 B)      & \cmark     & \cmark   \\
            Flush + Flush~\cite{gruss2016flush+}              & Cache            & Cache Line (64 B)      & \cmark     & \xmark   \\
            Controlled-channel Attack~\cite{xu2015controlled} & Page Tables      & Page (4 KB)            & \cmark     & \xmark   \\
            TLBleed~\cite{gras_translation_2018}              & MMUs             & TLB Set (4 KB)         & \cmark     & \xmark   \\
            Page Cache Attacks~\cite{gruss2019page}           & Page Cache       & Page (4 KB)            & \xmark     & \cmark   \\
            \bottomrule
        \end{tabular}
    }
\end{table}


Table~\ref{table:side_channel_attack} shows some representations of recent side-channel attacks. For a detailed overview of recent side-channel attacks, we refer to the following survey paper~\cite{ge2018survey}. We classified those side-channel attacks into two categories: cache-level channels and page-level channels.

\subsection{Cache-level Channel}
A CPU cache is an essential part of modern computer systems. It is a smaller and faster memory that is designed to reduce the average data access costs to the main memory by storing copies of data from the main memory. When a CPU reads data from a memory location, it first checks the cache. If it finds that the cache has a copy of data from the main memory, a cache hit occurs. Otherwise, the CPU needs to read from the main memory, and a cache miss happens.

Cache channels~\cite{yarom2017cachebleed,191010,184415,Osvik2006,liu2015last,184415} rely on the time difference between cache misses and cache hits. The core-private caches (e.g., L1 and L2) are traditionally set-associate cache. The cache is divided into different cache sets, and each cache set is made up of several cache lines. Cache channel attacks can observe cache accesses at the level of cache sets, cache lines or other granularities. We introduce two common attack strategies, namely Prime+Probe and Flush+Reload.

\textbf{Prime+Probe.} Prime+Probe targets a single cache set.
An attacker primes the cache set with its own data and waits until the victim executes the program. After that, the attacker probes the cache by reading previously-loaded data. If the victim accesses the cache set and evicts some lines of the data, the attacker will experience a slow measurement. Under the circumstance, the attacker can know the victim must have touched some data that mapping to the same cache set.

\textbf{Flush+Reload.} Flush+Reload allows an attacker to observe the memory at the granularity of cache line instead of a cache set. While Flush+Reload targets a single cache line, it requires the attacker and victim share some memory. During the ``flush'' stage, the attacker flushes the ``monitored
memory'' from the cache and waits for the victim to access the memory, who may load the sensitive information to the cache line.  In the next phase,
the attacker reloads the ``monitored memory''. By measuring the time differences brought by cache hits and misses, the attacker can infer the sensitive information. On X86-64 machines, the two steps can be combined by measuring the time differences of the \textsf{clflush} instruction.

Based on the above attacks, some work~\cite{brickell2011technologies} suggests having secret-dependent memory accesses at finer than the size of one cache line should be secure enough. However, recent studies shows that having different memory accesses within a cache line is also dangerous. One example is the CacheBleed attack~\cite{yarom2017cachebleed}. It is a cache channel attack can exploits cache-bank collisions. 
\subsection{Page-level Channel}
Page channel attacks allow an attacker can observe the memory access at the granularity of memory pages. One example is the controlled-channel attack~\cite{xu2015controlled}. It is a primary threat for the trusted execution environments (TEEs).  A privileged adversary (e.g., kernel) can infer the sensitive information by manipulating the enclave page accesses. A malicious OS can proactively revoke a virtual enclave memory page from the virtual memory. If the victim enclave program accesses the memory table, then the OS can observe the page faults and  know which page is accessed. While the granularity of the controlled-channel attacks is more coarse-grained compared with cache channel attacks, controlled-channel attacks allow the attacker to have a noise-free observation. Other examples like the TLB side-channel attack and DDRAM attacks share the same page-level granularity.


Based on the above discussion, we consider three types of granularities in the dissertation: byte (1 Byte), cache line size (64 Bytes), page size (4 KBs). To the best of our knowledge, the three types of granularities can cover most of the side-channel attacks in the literature.

\subsection{Attack Models}
Previous work~\cite{182946} classifies side-channel attacks into three type based on the type of information that an attacker can learn during the attack.
\subsubsection*{Timing-based Attacks}
In timing-based attacks, an adversary can monitor the execution time of a victim program. It could be the overall execution time or the execution time of some interesting points (e.g. a function).  The execution time is correlated to some events (e.g., cache hits and misses, page faults, the number of instructions). Examples of those attacks include remote timing attacks~\cite{brumley2005remote}, Bernstein's attack on AES~\cite{bernstein2005cache}, and Kocherâ€™s original attack~\cite{kocher1996timing} from CRYPTO 96.
\subsubsection*{Access-based Attacks}
In access-based attacks, an adversary can probe one time only after the termination of the victim program. The attacker can learn the memory addresses are that accessed during the execution. For example, a cache-based channel attack can know which memory access incurs a cache hit and which memory access incurs a cache miss. Since the attacker can probe the victim program after the execution, the attacker do not know the order of memory accesses. Access-based attacks often happen in the cloud computing environment when the attacker and victim share the same hardware (e.g., LLC Cache). Examples of those attacks include cache template attacks~\cite{191010}, Prime and Probe attacks~\cite{liu2015last}, and Flush and Reload attacks~\cite{yarom2014flush+}.
\subsubsection*{Trace-based Attacks}
In trace-based attacks, an adversary can probe the victim program at any point. The attacker can learn the order of memory accesses. Suppose the victim program has two functions \textsf{a} and \textsf{b}. In an access-based attacks, the attacker can only learn both \textsf{a} and \textsf{b} are executed. In a trace-based attacks, the attacker can know the execution sequence of two functions (e.g., $aabbb$). Controlled-channel attacks~\cite{moghimi2020copycat, xu2015controlled} belong to the category, where a malicious operating system can interrupt the victim applications and probe the program at any time. In general, the trace-based attack has the strongest assumption about the threat model,  but it can retrieve the more information compared to other two types of attacks.
\subsection{Target Applications}
There is a vast number of studies\cite{yarom2017cachebleed,191010,184415,Osvik2006,liu2015last} on side-channel attacks. Most early work targets on the encryption key on cryptography libraries. In recent years, researchers start to focus on more general target applications. In summary, current side-channel target applications can be classified into the below three categories.

\subsubsection*{Cryptography Libraries}
\begin{table}
    \centering
    \caption{This table shows some common vulnerable points in cryptography implementations and the corresponding protections.}
    \label{chapter2:table:crypto}
    \resizebox{\columnwidth}{!}{%

        \begin{tabular}{lll}
            \toprule
            Implementation & Common Vulnerable Point             & Mitigation \\ \midrule
            AES &  T-table and S-table lookups   & AES instructions (AES-NI) 
            \\&&Scalar bit-slicing \\&& Preloading tables     \\
            DES & Table lookups & Scalar bit-slicing (No implmentation) \\
            RSA & CRT optimization & Verifying the consistency with the public key\\
            & Modular exponentiation& Montgomery modular multiplication\\
            & & Base blinding and exponent blinding\\
            (EC)DSA & Scalar multiplication& Constant time scalar implementation\\
            &Modular inversion & Blinding\\
            &Modular reduction &\\
            \bottomrule
        \end{tabular}
        }
\end{table}

The first side-channel attack to cryptography libraries can be traced back to Kocher's timing attacks~\cite{kocher1996timing} in 1996. It exploits the the simple modular exponentiation algorithm function in many algorithms (Diffie-Helloman, RSA) implementations. The function does not run in a fixed time. By measuring the time differences between the modular exponentiation algorithm computes the exponent bits (0 or 1), Kocher's attack can recover the whole secret key bit by bit. Since then, researchers start to break all kinds of cipher implementation through side-channel attacks.  Table~\ref{chapter2:table:crypto} summarizes some common vulnerable points in cryptography library implementations.  Note that Cryptography libraries usually have several implementations for some ciphers.
For example, AES can have more than five different implementations  in OpenSSL. Depending on the build configuration and the return value of \textsf{CPUID}, the code may execute any implementation of them. The reference implementation usually adopts T-Tables and S-Tables to speed up the computation. However, such implementations are vulnerable to side-channels and can be exploited to retrieve the whole key~\cite{bonneau2006cache}. In addition to the reference implementation, those libraries also have side-channel mitigated versions. However, recent studies also shows those versions (e.g., AES-NI) also have side-channel vulnerabilities caused by compiler optimizations and human mistakes~\cite{217537}. The situation is even worse for asymmetric ciphers (e.g., Diffie-Helloman, RSA, ECDSA), because those those ciphers have a lots of big number calculations. It is hard to implement those calculations completely side-channel resistant. Recent work~\cite{arnaud2013timing,yarom2017cachebleed,yarom2014flush+} has demonstrated several end-to-end attacks to recover the private keys of those ciphers. There are two common countermeasures to mitigate the side-channel attacks in cryptography libraries. The first approach is to adopt constant time operation when computing the secret data.  It is hard to migrate all the code into a constant time implementation. The second approach is to use blinding to reduce the information that can attacker can retrieve. However, the binding value can also be retrieved by an attacker through other attacks including side-channel attacks. 

\subsubsection*{Machine Learning Applications}
Recent side-channel attacks on machine learning applications mainly focus on recovering two types of the sensitive information: the input of the model, and the architecture of deep learning models. Hua et al.~\cite{hua2018reverse} were the first in the literature to reverse engineer the architecture of convolutional neural networks (CNNs) through the memory access patterns. Wei et al.~\cite{wei2018know} perform the side-channel attacks on an FPG-based convolution neural network based on the power consumption to recover inputs to the networks. For an image classification task trained by the MNIST dataset, their attacks can achieve up 89\% accuracy. CSI NN~\cite{batina2019csi} reverse engineer the multi-layer perception and convolution neural network based on the electromagnetic signals (EMs). Cache Telepathy~\cite{yan2020cache} introduces the cache based side-channel attack to extract DNNs' architectures. We find that all existing approaches need a lot of domain knowledge and expertise to launch the attacks.
\subsubsection*{Media and Graphic Libraries}
Recent work also studies the side-channel attacks in media and graphic libraries. Gruss el at.~\cite{191010} shows an attack that can infer keystrokes by exploiting secret-dependent memory accesses in the GDK library. In the controlled-channel attack~\cite{xu2015controlled}, Yuanzhong et al. demonstrate an attack to recover the outline of the image by exploiting the vulnerability in the inverse DCT function in libjpeg. Daimeng et al.~\cite{wang2019unveiling} present the cache attack in graphic libraries. Their approaches combine a machine learning approach. They use the machine learning to pick cache lines that can be exploitable to leak most information.
\subsubsection*{Others}
Some other side-channel targets also include spell checking tools, and font libraries~\cite{xu2015controlled}. The attack to font libraries is essentially the same as the attack to the graphic library like GTK. By exploiting the differences of memory accesses when the program renders different characters, an attacker can recover parts of the original sensitive information. Other side-channel attacks target on the OS's kernel. One example is the to use the side-channel attacks to break the kernel address space randomization (KASLR).
Many exploits rely on the knowledge of the memory location of a certain kernel function. Since Linux 4.12, the kernel loads core kernel image and device drivers at random positions during the boot time. Jang et al.~\cite{jang2016breaking} rely on side-channels to reveal mapping status of each page. After that, they detect kernel modules with unique size signatures to break KASLR. The second example relies on the side-channel vulnerabilities~\cite{cao2019principled} inside kernels to infer the TCP sequence numbers, which can be used to hijack connections between the client and the server~\cite{cao2016off}.

\section{Detection and Mitigation}
There are several existing work on side-channel leakage detections. According to Table~\ref{table:side_channel_detection_tool}, existing methods can be classified into two categories, tools based on the trace comparison and tools based on the abstraction.

\textbf{Trace comparison.} If a program has two different execution traces under two different sensitive inputs, then attackers can distinguish the sensitive input by observing the execution trace. Therefore, we can conclude the program is vulnerable to side-channel attacks. The method is similar to the UNIX tool \textsf{diff}.  The approach does not need to model or abstract the program's semantics. In general, the approach is quite fast. On the negative side, comparing the trace along can find the leakage, but it cannot find the complex relationship between the leakage site and the original buffer. For example, if two leakage sites leak the same information in the original buffer, those approaches cannot find out the two leakage sites are the same.

\textbf{Abstraction.} The second category of those tools belongs to the field of abstractions. Tools based on those approaches use the abstraction to generate approximations of the semantics of computer programs. After that, by analyzing the model, those tools can identify side-channel leakages. Compared with the trace comparison approach, the method is more precise.

Those methods usually follow the below steps. Suppose a program $P$ has $k$ as the input. Those approaches first retrieve the relationship between the $k$ and temperate values during the execution. After that, they should have a cache or memory access model and model the side-channel leakage as a math constraint. By using SMT solvers to find if two different secret inputs can lead to access to different locations in the memory or the cache, those approaches can determine if the program is vulnerable to side-channel attacks.
Contrary to the trace comparison, the method is quite precise. Moreover, it can model multiple leakages precisely as the conjunction of those formulas. However, such approaches have the following limitations.

\begin{itemize}
    \item Many tools can only analyze the source code or the intermediate representation level. However, side-channel are low-level problems in general.  Most existing tools are research prototype or are implemented based on the research prototype. For some projects, the tool is only implemented to handle the benchmark in their papers properly. 
    \item Those tools heavily rely on SMT solvers. Despite SMT solvers have made incredible progress in terms of the performance, SMT solving is still the main bottlenecks of the many frameworks. SMT solvers are not good at non-linear arithmetic. However, such non-linear arithmetics are quite common in some cryptography algorithms.  Recent studies show existing solvers still have plenty of bugs when it deals with real number calculations. Those calculations are also common in media libraries and machine learning applications.
\end{itemize}

According to Table~\ref{table:side_channel_detection_tool}, some methods may choose to analyze the source code or the intermediate representations of the vulnerable software. However, it still cannot solve the problem. First, many widely-used libraries (e.g., Intel MKL) do not open the source code. Second, some libraries use hand code assembly code to pursue the maximum performance. CacheAudit~\cite{182946} uses abstract domains to compute an
over approximation of cache-based side-channel information leakage upper bound.
However, it is difficult to judge the sensitive level of the side-channel leakage based on
the leakage provided by CacheAudit. CacheS~\cite{236338} improves the approach from
CacheAudit with a new abstract model that only track
secret-related code. Like CacheAudit, CacheS cannot
indicate the sensitive level of side-channel vulnerabilities.
CaSym~\cite{Brotzman19Casym} introduces a static cache-aware symbolic
reasoning technique to cover multiple paths in a target program. Again, their
approaches cannot evaluate the sensitive level for each side-channel
vulnerability, and it only work on small code snippets.

The dynamic approach, usually consists of taint analysis and symbolic execution,
can perform a very precise analysis. CacheD~\cite{203878} takes a concrete execution trace and runs symbolic execution on the trace
to get the formula of each memory address. CacheD is
quite precise in avoiding false positives. However, CacheD is not able to detect secret-dependent control-flows. We adopted a similar approach to model the secret-dependent data accesses. \tool{} differs from CacheD in that we do not use traditional taint tracking or domain knowledge to cut the trace when identifying secret-dependent data access vulnerabilities. \tool{} works on machine instructions directly instead of intermediate representations. Moreover, \tool{} finds secret-dependent control-flows at the same time and gives a precise quantification of the leakage. DATA~\cite{217537} detects address-based side-channel vulnerabilities by comparing different execution traces under various test inputs. After collecting execution traces, DATA aligns them and finds the differences. It uses statistical hypothesis testing to find true leakages. However, both imperfect trace alignment and statistical testing result that DATA can produce false positives.
MicroWalk~\cite{Wichelmann:2018:MFF:3274694.3274741} uses mutual information (MI) between sensitive input and execution state to detect side-channels.

\begin{sidewaystable}

    %\begin{table*}
    %\centering
    \caption{Existing leakage detection tool only evaluate them on cryptography library. 1. Most recent work only evaluates their approaches on cryptography libraries. 2. All of them can not reason about the total effect of multiple leakages.}
    \label{table:side_channel_detection_tool}
    \resizebox{1\columnwidth}{!}{%

        \begin{tabular}{lllcclc}
            \toprule
            Tool                                                 & S/D     & Method                              & AVX/SIMD & Multiple & Evaluation                                           & Available \\ \midrule
            CacheAudit~\cite{182946}                             & Static  & Abstraction                         & \xmark   & \xmark   & Crypto Algorithm                                     & \cmark    \\
            CacheD~\cite{203878}                                 & Dynamic & Symbolic Execution + Taint Analysis & \xmark   & \xmark   & Libgcrypt, OpenSSL                                   & \xmark    \\
            CachSym~\cite{Brotzman19Casym}                       & Static  & Symbolic Execution                  & \xmark   & \xmark   & Crypto Snippet                                       & \xmark    \\
            CacheS~\cite{236338}                                 & Static  & Abstract Interpretation             & \xmark   & \xmark   & Libgcrypt, OpenSSL, mbedTLS                          & \xmark    \\
            DATA~\cite{217537}                                   & Dynamic & Trace Alignment + Comparison        & \cmark   & \xmark   & OpenSSL, PyCrypto                                    & \cmark    \\
            ctgrind~\cite{langley2010ctgrind}                    & Dynamic & Taint Analysis                      & \cmark   & \xmark   & Crypto Library                                       & \cmark    \\
            Satcco~\cite{xiao2017stacco}                         & Dynamic & Trace Comparison                    & \cmark   & \xmark   & OpenSSL, GnuTLS, mbedTLS, WolfTLS, LibreSSL          & \xmark    \\
            ANABLEPS~\cite{wang2019time}                         & Dynamic & Trace Comparison                    & \cmark   & \xmark   & gsl, Hunspell, PNG, Freetype, QRcodegen, Genometools & \xmark    \\
            MicroWalk~\cite{Wichelmann:2018:MFF:3274694.3274741} & Dynamic & Trace Comparison                    & \cmark   & \xmark   & Intel IPP, Microsoft CNG                             & \cmark    \\
            \bottomrule
        \end{tabular}
    }
    %\end{table*}
\end{sidewaystable}
Both hardware~\cite{Page2005PartitionedCA,
    Wang:2007:NCD:1250662.1250723,Zhang:2015:HDL:2775054.2694372,Li:2014:SLH:2541940.2541947,
    236344, 236334} and software~\cite{shih2017t,Coppens:2009:PMT:1607723.1608124,
    brickell2006software,crane2015thwarting, 197207} side-channels mitigation techniques have
been proposed recently. Hardware countermeasures, including partitioning hardware resources~\cite{Page2005PartitionedCA}, randomizing cache
accesses~\cite{Wang:2007:NCD:1250662.1250723, 236344}, and designing new
architecture~\cite{tiwari2011crafting}, require changes to complex processors and are complex to adopt. On the contrary, software approaches are
usually easy to implement. Coppens et
al.~\cite{Coppens:2009:PMT:1607723.1608124} uses a compiler
to eliminate key-dependent control-flow transfers. Crane et
al.~\cite{crane2015thwarting} mitigated side-channels by randomizing software.
As for crypto libraries, the basic idea is to eliminate key-dependent
control-flow transfers and data accesses. Common approaches include
bit-slicing~\cite{konighofer2008fast,rebeiro2006bitslice} and unifying
control-flows~\cite{Coppens:2009:PMT:1607723.1608124}.

\section{Quantification}
Proposed by Denning~\cite{robling1982cryptography} and Gray~\cite{gray1992toward},
Quantitative Information Flow (QIF) aims at providing an estimation of the amount of leaked information from the sensitive information given the public output. If zero bits
of the information are leaked, the program is called non-interference. 
McCamant and Ernst~\cite{McCamantE2008} quantify the information leakage as the network
flow capacity. They model the possible information leakage as a network of limited-capacity
channel. After that, they use the maximum rate of the channel to represent the amount of 
secret information that the execution can reveal.
Backes et al.~\cite{5207642} propose an automated method for QIF
by computing an equivalence relation on the set of input keys. However,
the evaluation shows the approach only works on small programs.
Besides, their approach cannot handle programs with bitwise operations.
However, such bitwise operations are quite common in cryptographic libraries.
Phan et al.~\cite{Phan:2012:SQI:2382756.2382791} propose symbolic QIF. The goal of their
work is to ensure a program is non-interference. They adopt an over
approximation method to estimate the total information leakage and their method
does not work for secret-dependent memory access side-channels.
Pasareanu et al.~\cite{pasareanu2016multi} combine symbolic analysis and Max-SMT solving to synthesize the concrete public input that can lead to the worst case leakage. They assume the target program has multiple different input secrets and calculate the average leakage for one-fixed public input.
CHALICE~\cite{Chattopadhyay:2017:QIL:3127041.3127044} quantifies the leaked
information for a given cache behavior.
It symbolically reasons about cache
behavior and estimates the amount of leaked information based on cache miss/hit.
Their approach only scale to small programs, which limits its usage in
real-world applications. On the contrary, \tool{} assesses the sensitive level
of side-channels with different granularities. It can also analyze side-channels in real-world cryptographic libraries.

Model counting refers to the problem of computing the number of satisfying
solutions for a propositional formula (\#SAT). There are two approaches to
solving the problem, exact model counting and approximate model
counting. Exact model counting for propositional formulas (\#SAT) should determine
the number of solutions. Intuitively, such model counter should traverse the whole
search space to find all the satisfying solutions. Consequently, exact model counter is 
very slow. Those model counters have difficulty scaling up to real-world programs.
On the other hand, approximate model counter is much faster compared with the exact 
model counter. The related work focus on approximate model counting since it is close to our approach. Wei and Selman~\cite{wei2005new} introduce
ApproxCount, a local search based method using Markov Chain Monte
Carlo (MCMC). ApproxCount has the better scalability than
exact model counters. Other approximate model counter includes
SampleCount~\cite{gomes2007sampling},
Mbound~\cite{gomes2006model}, and MiniCount~\cite{kroc2008leveraging}.
Unlike ApproxCount, these model counters can give lower or upper bounds with guarantees.
Despite the rapid development of model counters for SAT and some
research~\cite{chistikov2017approximate,phan2015model}, existing tools cannot be directly applied to side channel leakage quantification for the following two reasons.
ApproxFlow~\cite{biondi2018scalable} uses ApproxMC~\cite{chakraborty2016algorithmic} for information flow quantification, but it has only been tested with small programs.

\section{Trace-based Binary Analysis}
Trace-based binary analysis can be seen as a type of dynamic analysis. It 
analyzes one concrete program path one time rather than trying to cover
as many paths as possible. Compared to static analysis, trace-based analysis
is usually more precise as it can use runtime information. It usually has
two steps. The first step is collecting trace information. Existing
approaches usually often rely on binary instrumentation frameworks or emulators (e.g, Intel Pin~\cite{luk2005pin},
Valgrind~\cite{nethercote2007valgrind}, QEMU). The second step is analyzing the trace using techniques, such
as symbolic execution, taint analysis. Depending on when the analysis is launched,
there are two kinds of trace-based analysis, online analysis and offline analysis.
As the name suggests, online analysis is performed at runtime. The target program's
data can be modified directly in memory, which is useful in fuzzing because the analysis
can force the program to go through into a specific branch. Contrary to online analysis,
offline analysis or post analysis happens when the program finish executions. 
Trace-based binary analysis has been adopted in several tasks like algorithm
detection, vulnerability detection and malware analysis. We only mention a few of
most related works here. Xu et al.~\cite{xu2017cryptographic} introduce bit-wise symbolic execution, which can
identify crypto algorithms in obfuscated binaries. Ming et al.~\cite{ming2017binsim} use 
system call sliced segment equivalence checking to do binary diffing. Jia et al.~\cite{jia2017towards}
perform an offline analysis on execution traces to identify heap overflows.

There are several known binary analysis frameworks that can ease users 
to launch analysis on binary executable. BitBlaze~\cite{brumley2011bap} is a binary analysis platform
that provides both the static and dynamic analysis. It uses tracecap plugin to 
collect execution trace and convert the trace into Vine IR. Binary Analysis Platform (BAP)
is an another binary analysis platform. Similar to BitBlaze, it use a Pintrace tool to
collect execution trace and convert the trace into BAP IR. Angr~\cite{shoshitaishvili2016state}, the most popular
binary analysis platform recently, also support trace-based analysis. It first convert
each instruction into VEX IR and interpret each IR in Python. 

Above existing well-known binary analysis frameworks all adopt the IR layer, which make
it easy to implement the framework and support multiple architectures. However, it can have
a very low efficiency and long traces. All IR must be interpreted no matter if symbolic variables
are involved or not. Besides, as side-channels are low level problems in general, the IR
design will also lose some information. For example, IR-level branches are not necessarily 
a super-set or a sub-set of machine-code level branches. Some IR-level branches can be compiled into
non-branch instructions like conditional moves. Those above limitations motivate us to
implement a new trace-based binary analysis framework.
