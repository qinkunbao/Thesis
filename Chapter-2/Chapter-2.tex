% !TEX root = ../YourName-Dissertation.tex

\chapter{Related Work}\label{chapter2}
This chapter introduces the related work in this dissertation. We present the related work from the following aspects: side-channel attacks, detections, mitigation, and information quantification.

\section{Side-channel Attacks}
While there are many kinds of side-channel attacks, we focus on address-based side-channel attacks in this dissertation.
Address-based side-channel attacks happen when a program accesses different memory locations when it processes different secrets. In many situations, an attacker may shares some hardware resources (e.g., Cache, TLB, and DRAM) with the victim in today's computer system ~\cite{ge2018survey,szefer2019survey}. As a result, the attacker can probe the shared hardware resource to infer the memory accesses of the victim. While the root cause of the attack is the same, there are various approaches and an attacker can exploit the vulnerability to retrieve the information at different granularities. 

\begin{table}
\centering
\caption{Due to the page limit, we only shows some representations of the vast side-channel attacks: Attacks, the shared hardware resources with attackers, the granularity of the attacker can observe, is there any published attacks on non-cryptography library and if the type of attack can exploit multiple leakage sites.}
\label{table:side_channel_attack}
\resizebox{\columnwidth}{!}{%

\begin{tabular}{lllcc}
\toprule
Attacks & Shared Resources & Granularity  & Non-Crpyto & Multiple   \\ \midrule
CacheBleed~\cite{yarom2017cachebleed} & Cache & Sub Cache Line (<64 B)  & \xmark & \xmark \\ 
CopyCat~\cite{moghimi2020copycat} & Page Tables   & Instruction   & \xmark &  \xmark \\
Prime + Probe~\cite{liu2015last} & Cache & Cache Set (64-512 B)  & \cmark &   \xmark \\
Prime + Abort~\cite{disselkoen2017prime+} & Cache  & Cache Set (64-512 B) & \cmark &  \xmark   \\
Flush + Reload~\cite{yarom2014flush+} & Cache & Cache Line (64 B) & \cmark  &  \cmark \\
Flush + Flush~\cite{gruss2016flush+} & Cache & Cache Line (64 B) & \cmark & \xmark  \\
Controlled-channel Attack~\cite{xu2015controlled} & Page Tables & Page (4KB) & \cmark & \xmark \\
TLBleed~\cite{gras_translation_2018} & MMUs & TLB Set (4KB) & \cmark  & \xmark \\
Page Cache Attacks~\cite{gruss2019page} & Page Cache &  Page (4KB) & \xmark &  \cmark \\ 
\bottomrule
\end{tabular}
}
\end{table}
 
 
Table~\ref{table:side_channel_attack} shows some representations of the recent side-channel attacks. For a detailed overview of recent side-channel attacks, we refer to the following survey paper~\cite{ge2018survey}. We classified those side-channel attacks into two categories: cache channels and page channels.

\subsection{Cache-level Channel}
A CPU cache are an essential part in modern computer systems. It is a smaller and faster memory which is designed to reduce the average data access costs to the main memory by storing copies of data from the main memory. When a CPU reads data from a memory location, it first checks the memory location in the cache. If it finds that the cache stores a copy of the memory location, a cache hit occurs. Otherwise, the CPU needs to read the data from the main memory and a cache miss happens.
Cache channels~\cite{yarom2017cachebleed,191010,184415,Osvik2006,liu2015last,184415} rely on the time difference between cache misses and cache hits. Cache channel attacks can observe cache accesses at the level of cache sets, cache lines or other granularities. We introduce two common attack strategies, namely Prime+Probe and Flush+Reload. 

\textbf{Prime+Probe.} Prime+Probe targets a single cache set. 
An attacker primes the cache set with its own data and waits until the victim executes the program. After that, the attacker probes the cache by reading previously-loaded data. If the victim accesses the cache set and evicts some lines of the data, the attacker will experience a slow measurement. Under the circumstance, the attacker can know the victim must have touched some data that mapping to the same cache set.

\textbf{Flush+Reload.} Flush+Reload allow an attacker to observe the memory at a fine granularity. It targets at a cache line instead of a cache set. While Flush+Reload targets a single cache line, it requires the attacker and victim share some memory. During the ``flush'' stage, the attacker flushes the ``monitored
memory'' from the cache and waits for the victim to access the memory,
who may load the sensitive information to the cache line. On X86 machines, it can be achieved by using the \textsf{clflush} instruction. In the next phase,
the attacker reloads the ``monitored memory''. By measuring the time difference
brought by cache hit and miss, the attacker can further infer the sensitive information. Some other types of side-channels target different hardware
layers other than CPU cache.

Cache channels rely on the time difference between cache misses and cache hits. A cache channel works when the victim program and the attacker's program shares some sized chunks like cache lines or cache sets. Recent studies shows that an attacker can even observe the address access at a finer granularity (e.g., CacheBleed). Page-level side-channels allow attackers observe the memory access at the granularity of memory pages. 

\subsection{Page-level Channel}
Recent studies also shows the attacks can observe the memory access at the granularity of memory pages. One example is the controlled-channel attack~\cite{xu2015controlled}, where a privileged adversary try to infer the sensitive information by manipulating the enclave page access. Those kinds of attacks usually happen on the shielding system. A malicious OS can proactively revoke a virtual enclave memory page from the memory. If the victim enclave program accesses the memory table, then the adversary can know which page is accessed by observing the page fault sequence. While the granularity of the controlled-channel attacks is coarse-grained, the controlled-channel attacks allow the attacker to have a noise-free observation. Other examples like the TLB side-channel attack, DDRAM attacks share the same page-level granularity.


In this paper, we consider three types of granularity: byte (1 Byte), cache line size (64 Bytes), page size (4 KBs). To the best of our knowledge, the three types of granularities can cover most of the side-channel attacks in literature.

\subsection{Target Applications}
While there is a vast number of studies\cite{yarom2017cachebleed,191010,184415,Osvik2006,liu2015last} on side-channel attacks and detections, we find many of those work targets on the encryption key on cryptography libraries. In terms of the non-cryptography side-channel attacks. We find many of them can be classified into the below three categories.

\subsubsection{Cryptography Libraries}

\subsubsection{Machine Learning and Deep Learning Models}
Previous side-channel attack mainly focus on recovering the input of the model and reversing the architecture of deep learning models. Hua et al.~\cite{hua2018reverse} were the first reverse engineer the architecture of neural networks. Wei et al.~\cite{wei2018know} perform the side-channel attacks on an FPG-based convolution neural network based on the power consumption to recover the real-world inputs. For the MNIST dataset, their attacks can achieve up 89\% accuracy. On the contrary, our attack based on the page access information can achieve accuracy. CSI NN~\cite{batina2019csi} reverse engineer the multi-layer perception and convolution neural network based on the Electromagnetic signal. Cache Telepathy~\cite{yan2020cache} introduce the cache based side-channel attack to extract DNN architecture. We mention that all existing approach need a lot of domain knowledge and expertise to launch the attack.
\subsubsection{Media and Graphic Libraries}
A few of recent work also studies the side-channel in media and graphic libraries. In the first controlled-channel attack~\cite{xu2015controlled}, they can recover the outline of the image by exploiting the vulnerability in the inverse DCT leakage site. Daimeng et al.~\cite{wang2019unveiling} present the cache attack in graphic libraries. Their approaches also combine a machine learning approach. However, they use the machine learning to infer the best exploitable cache line, while our approach use the machine learning to infer the total leaked information.
\subsubsection{Others}
Some other side-channel targets also include spell checking tools, and font libraries~\cite{xu2015controlled}. The attack to font libraries is essentially the same to the attack to the graphic library like GTK. By exploiting the differences of memory accesses when the program render each character, an attacker can recover part of the original sensitive information. We find most of those side-channel attacks target the trusted execution environments. We think part of the reason is that it is easy to argue that information in those libraries is also sensitive to users as well.

\section{Detection and Mitigation}
While there are several existing work on side-channel leakage detections, we find it very hard to apply existing methods to identify controlled-channel attacks. According to Table~\ref{table:related_work}, existing methods can be classified into two categories, tools based on the trace comparison and tools based on the abstraction. 

\textbf{Trace comparison.} If the victim program has two different execution traces with two different sensitive inputs, then we can distinguish the sensitive input by observing the execution trace. Therefore, we can conclude the program is vulnerable to side-channel attacks. The method is similar to UNIX tool \textsf{diff}. Moreover, the approach does not need to model or abstract the program's semantics. In general, the approach is quite salable. On the negative side, comparing the trace along can only find the leakage, but it cannot find the complex relationship between the leakage site and the original buffer. For example, if two leakage sites leak the same information in the original buffer, those approaches cannot find out the two leakage sites are the same. 

\textbf{Abstraction.} The second category of those tools belongs to the field of abstractions. Tools based on those approaches use the abstraction to generate approximations of the semantics of computer programs. After that, by analyzing the model, those tools can identify side-channel leakages. Comparing with the trace comparison approach, the method is more precise. 

Those methods usually follow the below steps. Suppose a program $P$ has $k$ as the input, we can run symbolic execution on the top the victim program. So temporary values can be represented as math formulas. After that, we need to build a cache or memory access model and model the side-channel leakage as a math constraint. Then we use SMT solvers to find if there are two different secret inputs that can lead to access different locations in the memory or the cache. If so, then the program is vulnerable to side-channel attacks. Contrary to the trace comparison, the method is quite precise. Moreover, it can model multiple leakages precisely as the conjunction of those formulas. However, after some initial investigations and experiments, we find such approach fails in practice due to the below reasons. 

\begin{itemize}
    \item Existing tools cannot not handle many instructions such as AVX, and SIMD instructions.  Most existing tools are research prototype or are implemented based on the research prototype. For many projects, the tool is only implemented to properly handle the benchmark in their papers. Second, many those tools rely on transferring those instructions into some intermediate languages. However, those intermediate languages do not support those architecture instructions. 
    \item Today's solvers can not handle many complicated constraints, especially the conjunction of those constraints. Recent studies show existing solver have bugs when it deals with floating pointer calculations.
\end{itemize}

According to Table~\ref{table:side_channel_detection_tool}, some methods may choose to analyze the source code or the intermediate languages. However, it still cannot solve the problem. First, many widely-used libraries (e.g., Intel MKL) do not open the source code. Second, some libraries use hand code assembly code to pursue the maximum performance. CacheAudit~\cite{182946} uses abstract domains to compute an
over approximation of cache-based side-channel information leakage upper bound.
However, it is difficult to judge the sensitive level of the side-channel leakage based on
the leakage provided by CacheAudit. CacheS~\cite{236338} improves on
CacheAudit with new abstract domains that only track
secret-related code. Like CacheAudit, CacheS cannot
indicate the sensitive level of side-channel vulnerabilities.
CaSym~\cite{Brotzman19Casym} introduces a static cache-aware symbolic
reasoning technique to cover multiple paths in a target program. Again, their
approaches cannot evaluate the sensitive level for each side-channel
vulnerability, and it only work on small code snippets.

The dynamic approach, usually consists of taint analysis and symbolic execution,
can perform a very precise analysis. CacheD~\cite{203878} takes a concrete execution trace and runs symbolic execution on the trace
to get the formula of each memory address. CacheD is
quite precise in avoiding false positives. However, CacheD is not able to detect secret-dependent control-flows. We adopted a similar approach to model the secret-dependent data accesses. \tool{} differs from CacheD in that we do not use traditional taint tracking or domain knowledge to cut the trace when identifying secret-dependent data access vulnerabilities. \tool{} works on machine instructions directly instead of intermediate representations. Moreover, \tool{} finds secret-dependent control-flows at the same time and gives a precise quantification of the leakage. DATA~\cite{217537} detects address-based side-channel vulnerabilities by comparing different execution traces under various test inputs. After collecting execution traces, DATA aligns them and finds the differences. It uses statistical hypothesis testing to find true leakages. However, both imperfect trace alignment and statistical testing result that DATA can produce false positives.
MicroWalk~\cite{Wichelmann:2018:MFF:3274694.3274741} uses
mutual information (MI) between sensitive input and execution state to detect side-channels. 

\begin{table}
    \centering
    \caption{Due to the page limit, we only shows some representations of the vast side-channel attacks: Attacks, the shared hardware resources with attackers, the granularity of the attacker can observe, is there any published attacks on non-cryptography library and if the type of attack can exploit multiple leakage sites.}
    \label{table:side_channel_detection_tool}
    \resizebox{\columnwidth}{!}{%
    
    \begin{tabular}{lllcc}
    \toprule
    Attacks & Shared Resources & Granularity  & Non-Crpyto & Multiple   \\ \midrule
    CacheBleed~\cite{yarom2017cachebleed} & Cache & Sub Cache Line (<64 B)  & \xmark & \xmark \\ 
    CopyCat~\cite{moghimi2020copycat} & Page Tables   & Instruction   & \xmark &  \xmark \\
    Prime + Probe~\cite{liu2015last} & Cache & Cache Set (64-512 B)  & \cmark &   \xmark \\
    Prime + Abort~\cite{disselkoen2017prime+} & Cache  & Cache Set (64-512 B) & \cmark &  \xmark   \\
    Flush + Reload~\cite{yarom2014flush+} & Cache & Cache Line (64 B) & \cmark  &  \cmark \\
    Flush + Flush~\cite{gruss2016flush+} & Cache & Cache Line (64 B) & \cmark & \xmark  \\
    Controlled-channel Attack~\cite{xu2015controlled} & Page Tables & Page (4KB) & \cmark & \xmark \\
    TLBleed~\cite{gras_translation_2018} & MMUs & TLB Set (4KB) & \cmark  & \xmark \\
    Page Cache Attacks~\cite{gruss2019page} & Page Cache &  Page (4KB) & \xmark &  \cmark \\ 
    \bottomrule
    \end{tabular}
    }
    \end{table}
    
Both hardware~\cite{Page2005PartitionedCA,
Wang:2007:NCD:1250662.1250723,Zhang:2015:HDL:2775054.2694372,Li:2014:SLH:2541940.2541947,
236344, 236334} and software~\cite{shih2017t,Coppens:2009:PMT:1607723.1608124,
brickell2006software,crane2015thwarting, 197207} side-channels mitigation techniques have
been proposed recently. Hardware countermeasures, including partitioning hardware resources~\cite{Page2005PartitionedCA}, randomizing cache
accesses~\cite{Wang:2007:NCD:1250662.1250723, 236344}, and designing new
architecture~\cite{tiwari2011crafting}, require changes to complex processors and are complex to adopt. On the contrary, software approaches are
usually easy to implement. Coppens et
al.~\cite{Coppens:2009:PMT:1607723.1608124} uses a compiler
to eliminate key-dependent control-flow transfers. Crane et
al.~\cite{crane2015thwarting} mitigated side-channels by randomizing software.
As for crypto libraries, the basic idea is to eliminate key-dependent
control-flow transfers and data accesses. Common approaches include
bit-slicing~\cite{konighofer2008fast,rebeiro2006bitslice} and unifying
control-flows~\cite{Coppens:2009:PMT:1607723.1608124}.

\section{Quantification}
Proposed by Denning~\cite{robling1982cryptography} and Gray~\cite{gray1992toward}, 
Quantitative Information Flow (QIF) aims at providing an estimation of the amount of leaked information from the sensitive information given the public output. If zero bits
of the information are leaked, the program is called non-interference. McCamant
and Ernst~\cite{McCamantE2008} quantify the information leakage as the network
flow capacity. Backes et al.~\cite{5207642} propose an automated method for QIF
by computing an equivalence relation on the set of input keys. But the approach
cannot handle real-world programs with bitwise operations. 
Phan et al.~\cite{Phan:2012:SQI:2382756.2382791} propose symbolic QIF. The goal of their
work is to ensure a program is non-interference. They adopt an over
approximation method to estimate the total information leakage and their method
does not work for secret-dependent memory access side-channels.
Pasareanu et al.~\cite{pasareanu2016multi} combine symbolic analysis and Max-SMT solving to synthesize the concrete public input that can lead to the worst case leakage. They assume the target program has multiple different input secrets and calculate the average leakage for one-fixed public input.
CHALICE~\cite{Chattopadhyay:2017:QIL:3127041.3127044} quantifies the leaked
information for a given cache behavior. 
It symbolically reasons about cache
behavior and estimates the amount of leaked information based on cache miss/hit.
Their approach only scale to small programs, which limits its usage in
real-world applications. On the contrary, \tool{} assesses the sensitive level
of side-channels with different granularities. It can also analyze side-channels
in real-world crypto libraries.

Model counting refers to the problem of computing the number of 
models for a propositional formula (\#SAT). There are two approaches to
solving the problem, exact model counting and approximate model 
counting. We focus on approximate model counting since it is our approach. Wei and Selman~\cite{wei2005new} introduce
ApproxCount, a local search based method using Markov Chain Monte 
Carlo (MCMC). ApproxCount has the better scalability than 
exact model counters. Other approximate model counter includes 
SampleCount~\cite{gomes2007sampling},
Mbound~\cite{gomes2006model}, and MiniCount~\cite{kroc2008leveraging}. 
Unlike ApproxCount,
these model counters can give lower or upper bounds with guarantees.
Despite the rapid development of model counters for SAT and some 
research~\cite{chistikov2017approximate,phan2015model} on Modulo Theories model counting (\#SMT),
they cannot be directly applied to 
side channel leakage quantification.
ApproxFlow~\cite{biondi2018scalable} uses ApproxMC~\cite{chakraborty2016algorithmic} for information flow quantification,
but it has only been tested with small programs.
