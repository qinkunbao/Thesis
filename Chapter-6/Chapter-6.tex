\chapter{Conclusion}\label{chapter6}
This dissertation research studies the address-based side-channel leakages in two aspects: detection and quantification. In the side-channel vulnerability detection research, we explore and solve the two bottlenecks in today's automated side-channel vulnerability detection tool, performance and precision. In the side-channel vulnerability quantification research, we propose two different side-channel leakage quantification tools based on information theory. 

\section{Summary}

In Chapter~\ref{chapter3}, we present a practical address-based side-channel detection tool, \detect{}, that is capable of detecting secret-dependent control-flows and data accesses at the same time. We model side-channel leakage sites as math constraints and use dynamic symbolic execution to generate constraints for possible leakages. Using statistical testing, \detect{} can identify the true leakages from those constraints. Besides, \detect{} analyze the side-channel leakages directly from X86 execution traces. Existing binary analysis tools usually transfer the x86 instruction to intermediate languages (IR) simplify the implementation. However, such designs have expensive overheads and imprecise analysis results. To tackle the problem, we take the engineering efforts and implement the analysis based on Intel developer's manual from scratch. We evaluate \detect{} on popular cryptographic libraries including OpenSSL, mbedTLS, Libgcrypt, and Monocyper. The evaluation results show that \detect{} is three times to one hundred times faster than the state of art tools while finding all the leakages reported by the previous tools. In addition, \detect{} identity new leakages. The new leakages was later confirmed by other researchers and software developers.  

In Chapter~\ref{chapter4}, we present a novel method to quantify address-based side-channel leakage. We quantify the amount of leakage information for a single trace attack. The amount of the leaked information is based on the search space reduced by side-channel attacks. We rely on \detect{} to detect side-channel leakages. After that, we use approximate model counting to quantify the leakage site. The method is implemented in a prototype tool called \tool{}. We show its effectiveness in quantifying side-channel leakage. With the new definition of information leakage that models actual side-channel attackers, quantifying the number of leaked bits helps understand the severity level of side-channel vulnerabilities. The evaluation confirms that \tool{} is useful in estimating the amount of leaked information in real-world applications.

In Chapter~\ref{chapter5}, we propose a fuzzing method to automatically detect and quantify the address-based side-channel leakages automatically. The proposed method can produce the conservative estimation of the side-channel leakage of the deterministic program. As a result, any severe leakage reported by \ctool{} is the true severe leakage. We also study the total effect of two leakages. Using statistical hypothesis testing, we are able to determine if the two leakages are independent. If so, we can calculate the sum of the amount of leakage by adding two leakages. Our evaluation result on both several libraries and benchmarks show that \ctool{} is effective and accurate in detecting the side-channel leakage.

In conclusion, this dissertation research develops practical techniques for precise side-channel analysis in software systems. For each proposed method, we implement and evaluate it on real-world software. The evaluation results show the effeteness and generality of our proposed method.  We open source the tools in the dissertation to facilitate future research in the area.
\section{Future Directions}
In the future, we plan to explore the following directions based on the dissertation research. 

\textbf{Kernel Space Side-channel Vulnerability Detection.} There are several side-channel vulnerability detection tools together with the dissertation tool. Most of the tools are designed to analyze the side-channel leakages in user-level applications like cryptographic libraries. It is reasonable since many side-channel attacks are used to break cryptographic applications. Recently, researchers also started to focus on side-channel attacks~\cite{cao2016off} inside the kernel space. However, it is non-trivial to apply existing side-channel detection tools in the Linux kernel. Take the method in the dissertation, for example. We may have the following challenges. First, our proposed tools in the dissertation rely on the dynamic binary instrumentation frameworks to collect the runtime information. As for kernel programs, a similar task can be achieved by some whole system emulators like BitBlaze~\cite{song2008bitblaze} and S2E~\cite{chipounov2012s2e}. S2E uses a modified Linux kernel and QEMU to trace the kernel components. S2E uses QEMU 1.0, which does not support the latest Linux kernel. The engineering efforts of extending S2E to work on the latest kernel are significant. Second, the kernel has very complicated control-flow graphs compared to cryptography libraries. Some vulnerabilities need to be triggered by specific input from the user space applications or devices. Our tool can not handle interruptions and exceptions. But they are common inside the kernel. On the positive side, we expect there are plenty of leakage sites inside the kernel. The dissertation provide the approaches to pick up ``severe'' leakages automatically.


\textbf{Compiler-assisted Side-channel Vulnerability Analysis and Mitigation.}
We propose to mitigate the side-channel leakages in a compiler backend. For example, the conditional execution can be eliminated by using the masks. Eliminating side-channel leakages from compilers is not a brand new idea. Coppens et al.~\cite{Coppens:2009:PMT:1607723.1608124} propose several methods to remove several approaches to eliminate all potential leakages that are related to data flow and control flow.  GNU toolchain adds new options (\textsf{-mlfence-after-load}, \textsf{-mlfence-before-indirect-branch}) to mitigate the Load Value Injection (LVI) attack during the compilation. Coppens et al.'s approach has a slowdown with a factor from 2 to 24. The LVI harden binaries generated from GNU toolchains takes 6-10x longer to run. The performance impact from the aggressive mitigation. For example, GNU toolchains inset LFENCE before any possible vulnerable instructions, which include all load instructions, all indirect branches, and return instructions. We plan only to change those points that are more likely to leak sensitive information. Even more, with the tool presented in the dissertation, we can only modify part of the ''severe`` leakage sites.